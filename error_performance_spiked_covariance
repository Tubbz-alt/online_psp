# Title: error_performance_spiked_covariance.py
# Description: Testing online PCA algorithm population and batch error on artificially generated data
# Author: Victor Minden (vminden@flatironinstitute.org) and Andrea Giovannucci (agiovannucci@flatironinstitute.org)
# Notes: Adapted from code by Andrea Giovannucci
# Reference: None
#%%
lslsl
#%%
# imports
from online_pca_simulations import run_simulation
import os
import pylab as plt
import numpy as np
# general parameters


error_options = {
    'n_skip': 20,
    'orthogonalize_iterate': False,
    'compute_batch_error': True,
    'compute_population_error': True,
    'compute_strain_error': False,
    'compute_reconstruction_error': False
}

generator_options = {
    'method': 'spiked_covariance',
    'lambda_q': 5e-1,
    'normalize': True,
    'rho': 1e-2 / 5,
    'scale_data': True
}

simulation_options = {
    'd': 200,
    'q': 50,
    'n': 1000,
    'n0': 0,
    'n_epoch': 1,
    'error_options': error_options,
    'pca_init': False,
    'init_ortho': True,
}

algos = ['if_minimax_PCA', 'incremental_PCA', 'CCIPCA']
algo = algos[0]
algorithm_options = {
    'pca_algorithm': algo,
    'tau': 0.5,
    'tol': 1e-7
}




def run_test(simulation_options=None, algorithm_options=None, generator_options=None):
    output_folder = os.getcwd() + '/test'

    errs = run_simulation(output_folder, simulation_options,
                          generator_options, algorithm_options)

    handles = []

    # fig = plt.figure(1)
    # ax = fig.add_subplot(1, 1, 1)
    # plt.title(algorithm_options['pca_algorithm'])
    # for err_name in errs:
    #     print(err_name + ': %f' % (errs[err_name][-1]))
    #     handle, = ax.plot(errs[err_name], label=err_name)
    #     handles.append(handle)
    # plt.legend(handles=handles)
    # plt.ylabel('Error (log10 scale)')
    # plt.xlabel('Iteration')
    # # plt.ylim(ymax=1, ymin=0)
    # ax.set_yscale('log')
    # plt.show()
    return errs


#%%
n_repetitions = 1
rhos = np.arange(.1, 1, .1)
simulation_options['n'] = 100
d_q_params = [(16,2), (64,4), (256,16), (1024, 16)]
results = dict()
counter = 0
colors = ['b','r','g']
for d, q in d_q_params:
    counter += 1
    ax = plt.subplot(1,4,counter)
    for algo in range(3):
        pop_err_avg = []
        batch_err_avg = []
        for rho in rhos:
            errs_pop = []
            errs_batch = []
            for reps in range(n_repetitions):
                print((d, q, rho))
                generator_options['rho'] = rho
                simulation_options['d'] = d
                simulation_options['q'] = q
                algorithm_options['pca_algorithm'] = algos[algo]
                err = run_test(generator_options=generator_options, simulation_options=simulation_options,
                                algorithm_options=algorithm_options)

                errs_pop.append(err['population_err'])
                errs_batch.append(err['batch_err'])

            errs_pop = np.array(errs_pop)
            errs_batch = np.array(errs_batch)
            output_dict = {
                'generator_options': generator_options,
                'simulation_options': simulation_options,
                'algorithm_options': algorithm_options,
                'd': d,
                'q': q,
                'n': simulation_options['n'],
                'n_epoch': 1,
                'n0': 0,
                'errs_batch': errs_batch,
                'errs_pop': errs_pop,
            }
            np.savez('./test/'+'__'.join(['rho', str(rho), 'd', str(d), 'q', str(q), 'algo', algos[algo]])+'.npz', **output_dict)
            results['__'.join([str(rho), str(d), str(q), algos[algo]])] = output_dict
            lsls

            pop_err_avg.append(np.mean(errs_pop[-1]))
            batch_err_avg.append(np.mean(errs_batch['population_err'][-1]))

        line_pop, = ax.plot(rhos, pop_err_avg, '-d' + colors[algo])
        line_bat, = ax.plot(rhos, batch_err_avg, '-o' + colors[algo])
        line_pop.set_label(algos[algo] + '_pop')
        line_bat.set_label(algos[algo] + '_batch')
        ax.legend()
        plt.pause(.1)


#%%
from glob import glob
results = dict()
fls = glob('test/*.npz')
fls.sort()
print(fls)
for fl in fls:
    with np.load(fl) as ld:
        rho = str(ld['generator_options'][()]['rho'])
        d = str(ld['simulation_options'][()]['d'])
        q = str(ld['simulation_options'][()]['q'])
        pca_algorithm = ld['algorithm_options'][()]['pca_algorithm']
        results['__'.join([rho, d, q, pca_algorithm])] = ld['errs'][()]

        # print(ld.keys())
        # go = ld['generator_options']
        # results['rho'] = ld['generator_options'][()]['rho']
        # results['d'] = ld['simulation_options'][()]['d']
        # results['q'] = ld['simulation_options'][()]['q']
        # results['pca_algorithm'] = ld['algorithm_options'][()]['pca_algorithm']
        # results['errs'] = ld['errs'][()]

#%%
counter = 0
for d, q in d_q_params:
    counter += 1
    ax = plt.subplot(1,4,counter)
    for algo in range(3):
        pop_err_avg = []
        batch_err_avg = []
        for rho in rhos:
            errs = results['__'.join([str(rho), str(d), str(q), algos[algo]])]
            pop_err_avg.append(np.mean(errs['batch_err']))
            batch_err_avg.append(np.mean(errs['population_err']))

        line_pop, = ax.plot(rhos, pop_err_avg, '-d' + colors[algo])
        line_bat, = ax.plot(rhos, batch_err_avg, '-o' + colors[algo])
        line_pop.set_label(algos[algo] + '_pop')
        line_bat.set_label(algos[algo] + '_batch')
        ax.legend()
        plt.pause(.1)



